# 설정 가이드 from GPT

# config.properties 설정 설명

| 키 | 설명 | 예시/기본값 |
|---|---|---|
| **app.port** | 서버가 바인딩할 포트 번호 | 18089 |
| **bucket.capacity** | 전역 토큰버킷의 최대 토큰 수(최대 burst 허용량) | 150 |
| **bucket.refill_per_sec** | 전역 토큰버킷의 초당 토큰 재충전 속도 | 2.5 |
| **bucket.idle_evict_ms** | 사용하지 않는 토큰버킷(유저별) 메모리에서 제거되는 유휴 시간(밀리초) | 600000 (10분) |
| **request.default_cost** | 기본 API 요청 1회당 소모되는 토큰 비용 | 1 |
| **request.mingap_ms** | 최소 요청 간격, 너무 짧은 간격으로 요청하는 사용자는 차단 하는 설정, 없으면 비활성화 됨 | |
| **identity.order** | 사용자 식별 우선순위(헤더, 쿠키, 쿼리, IP 등) | header:X-User-Id,cookie:uid,query:user |
| **server.boss_threads** | Netty Boss EventLoop 스레드 수(0=기본값) | 1 |
| **server.worker_threads** | Netty Worker EventLoop 스레드 수(0=기본값) | 0 |
| **http.max_content_length** | HTTP 요청 body의 최대 허용 크기(바이트) | 1048576 (1MB) |

---

## 상세 설명

- **app.port**  
  서버가 외부에서 접속을 받는 포트 번호.

- **bucket.capacity**  
  토큰버킷의 최대 토큰 수(최대 burst 허용량).  
  예: 150이면, 순간적으로 최대 150회 요청 허용.

- **bucket.refill_per_sec**  
  토큰버킷이 초당 몇 개의 토큰을 재충전하는지 설정.  
  예: 2.5면, 1초에 2.5개의 요청이 허용됨.

- **bucket.idle_evict_ms**  
  오랫동안 사용하지 않은 유저별 토큰버킷을 메모리에서 자동으로 제거하는 시간(밀리초).  
  메모리 사용량 관리에 영향.

- **request.default_cost**  
  각 API 요청이 기본적으로 소모하는 토큰의 양.  
  경로별로 override 가능.

- **request.mingap_ms**  
  minimum gap : 최소 요청 간격, 이 간격 미만으로 오는 요청 차단하는 설정, 없으면 비활성화됨.
  경로별로 override 가능.

- **identity.order**  
  사용자를 식별할 때 어떤 정보를 우선적으로 사용할지 순서를 지정.  
  예: header:X-User-Id → cookie:uid → query:user 순으로 시도.

- **server.boss_threads / server.worker_threads**  
  Netty 서버의 이벤트루프 스레드 개수.  
  0이면 Netty 기본값 사용.

- **http.max_content_length**  
  HTTP 요청의 최대 body 크기(바이트).  
  너무 큰 요청을 제한할 때 사용.

---

# bucket 설정

초당 10개의 요청을 허용하는 경우 :
bucket.capacity와 bucket.refill_per_sec를 설정하는 방법

- refill_per_sec 값은 초당 처리 개수를 설정함 : 예에서는 10으로 정함
- capacity 값은 동시 처리 개수를 설정함 : 목표에 맞게 설정함, 아래 예시 참고

| 목표 | 설정 | 효과 |
|-----|-----|-----|
| 엄격히 10 rps, 버스트 거의 없음 | refillPerSec=10, capacity=1 | 한 번에 1개만 통과, 0.1초마다 1개 충전 → 거의 균등 간격(최대 10 rps) |
| 보통(약간의 버스트 허용) | refillPerSec=10, capacity=10 | 최대 10개 즉시 처리 후 초당 10개 속도로 회복 |
| 버스트 넉넉히 허용 | refillPerSec=10, capacity=20~50 | 유휴 시간이 있었다면 한 번에 20~50개까지 쏟을 수 있음, 하지만 장기 평균은 10 rps로 수렴 |

# API 요청 속도 제한을 위한 토큰버킷 설정 가이드

"사람이 쓰는 앱/웹 트래픽은 불편하지 않게 통과,
curl/스크립트성 폭탄은 걸러내기"를 기준으로 **초당 평균 RPS 가이드**와
**버스트/방어 레이어**를 정리해볼게요.

------------------------------------------------------------------------

# 1) 기본 권장값 (토큰버킷: refill_per_sec / capacity)

사람 손가락·브라우저 자동화 패턴을 감안하면 아래 정도가 무난합니다.

 | 엔드포인트 유형  | RPS(refill_per_sec)  |   버스트(capacity)   | 메모     |
 | -------------|---------------------|---------------------|----------|
 | 인증/결제/중요  | **1 rps**  | **3** | 과도 호출은 의심. 429 mutate 후 쿨다운(예:10\~30초) |
 | 일반 조회(목록/상세) |  **3 rps** | **10** | 스크롤·탭 전환 고려 |
 | 검색/자동완성 | **5 rps** | **10**  | 타이핑 디바운스(≥150ms) 권장 |
 | 백오피스 그리드/차트  | **2 rps** |  **6** | 페이지네이션·캐시 활용 |
 | 파일 업/다운 API  | **0.5 rps** |  **2** | 대용량은 범위요청/서버사이드 URL 사용 |
 | 공용 키 없는 공개 API | **1 rps (IP당)**   |   **3** | IP/ASN 단위 제한 겸용 API | 

> "curl 방지"가 핵심이면, **사용자 단위 3\~5 rps + IP 단위 5\~10 rps**
> 이중 제한만 해도 체감 효과 큽니다.\
> 웹/앱 정상 사용은 보통 **동일 유저에서 10 rps 이상 지속**이 거의
> 없습니다(자동완성 제외).

------------------------------------------------------------------------

# 2) 추가로 강력해지는 레이어들 (가볍지만 효과 큼)

-   **이중 키 제한**: `userId(or session)` + `IP` 동시 토큰버킷. 어느
    하나 초과해도 429.
-   **엔드포인트별 최소 간격**: 같은 리소스에 **min gap 100--200ms**(소프트 게이트).
    → 토큰버킷 + "간격 제한"을 함께 쓰면 스크립팅이 매우 불편해집니다.
-   **점증 페널티**: 1분 내 429가 n회면, n에 비례해 **냉각 시간(Throttle window)** 증가(예: 10s→30s→120s).
-   **헤더·출처 체크(웹)**: `Origin/Referer` 화이트리스트, **SameSite=Lax/Strict** 쿠키, CSRF 토큰.
    *curl은 흉내낼 수 있어도, 여러 신호를 합치면 비용이 커짐.*
-   **TLS/클라이언트 신호**: `User-Agent` +`Sec-CH-UA*`/`Fetch metadata headers`(Sec-Fetch-Site/Mode/Dest) 검증. 비정상 조합(예: UA=Chrome인데 Sec-CH-UA 없음)은 더 낮은 한도 적용.
-   **HMAC 서명(앱)**: 요청 바디/쿼리 + 타임스탬프 + nonce를 **서명**. 만료(±60s), 1회용 nonce로 재사용 차단.*앱 리버스 가능성은 있지만, **서버 검증 + 레이트리미트**로 스크립팅 비용↑.
-   **동적 캡(시간대별·AS별)**: 새벽 스캔·특정 ASN(호스팅/클라우드)에서 과도 트래픽 시 한시적 하향.

------------------------------------------------------------------------

# 3)서버에 적용하는 숫자 예시

예를 들어 "일반 조회 3 rps / 버스트 10, 인증 1 rps / 버스트 3, 검색 5
rps / 버스트 10"로 간다면:

-   전역(보수적 백업): `bucket.refill_per_sec=3`, `bucket.capacity=10`\
-   `routes.conf` 예:

```
    allow ANY ^/health$

    # 인증/결제
    limit ANY ^/api/(login|checkout)$ cost=1 mingap=6000 # 로그인 등은 1초 간격
    # 일반 조회
    limit ANY ^/api/(items|detail).*$ cost=1 refill=3 burst=10
    # 자동완성
    limit GET ^/api/typeahead.*  cost=1 refill=10 burst=10
```

> **route별 capacity/refill 오버라이드**를 넣고 싶다면, 규칙에 `refill=`
> `capacity=`를 추가해 `(userKey + ruleId)`로 버킷을 분리하세요.

또한 **간격 제한(soft gate)**을 곁들이면 좋아요: - 같은 유저가 **같은
path 패턴**으로 들어오면, 이전 통과 시각과의 차가 `< 120ms`면 429 또는
지연
- 자동완성은 client쪽에서 150--200ms 디바운스 하는 것을 권장
- 인증/결제는 1-2초 간격 권장.

------------------------------------------------------------------------

# 4) 운영 팁

-   **초기엔 조금 낮게**(예: 2--3 rps) 시작 → 429율/에러율/응답시간을
    보며 단계적 상향.\
-   429가 **전체 요청의 1~2%** 사이면 적정, 5%↑면 과도(UX 저하).\
-   **화이트리스트**: 사내 IP·모니터링·배치 작업 키는 별도 규칙(allow or
    높은 한도).
-   **로그/메트릭**: 2xx/4xx/5xx, 429 카운트, 상위 IP/유저, 엔드포인트별
    히트/리밋, 평균 대기 추정치.

------------------------------------------------------------------------

## 한 줄 결론

아래 기능으로 curl/스크립트성 요청은 상당히 걸러낼 수 있습니다.

-   **일반 웹/앱**: 사용자당 **3 rps(버스트 10)** 가 안전한 출발점.
-   **민감/변경 API**: **1 rps(버스트 3)**.
-   **검색/자동완성**: **5 rps(버스트 10)** + **입력 디바운스 150 ~ 200ms**.
    여기에 **IP 동시 제한**, **간격 제한**, **점증 페널티**, **출처/서명 검증** 사용





